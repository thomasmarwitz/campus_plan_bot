"""Core Protocol Interfaces for the KIT Campus Navigator.

This file defines the simplified protocol interfaces for the main
components following the KISS principle as outlined in the project
specification.
"""

from collections.abc import Sequence
from datetime import datetime
from enum import Enum, auto
from typing import (
    Any,
    Protocol,
    TypedDict,
)

# --- Common Types ---


class InputType(Enum):
    TEXT = auto()
    AUDIO = auto()


class OutputType(Enum):
    TEXT = auto()
    SPEECH = auto()


class UserMessageProtocol(Protocol):
    """Protocol for a message from the user."""

    id: str
    timestamp: datetime
    content: str


class SystemMessageProtocol(Protocol):
    """Protocol for a message generated by the system."""

    id: str
    timestamp: datetime
    content: str


class ConversationProtocol(Protocol):
    """Protocol for the conversation history."""

    id: str
    messages: Sequence[UserMessageProtocol | SystemMessageProtocol]


class RetrievedDocument(TypedDict):
    """Represents a document retrieved from the database."""

    id: str
    content: str
    metadata: dict[str, Any]
    relevance_score: float


# --- Input Processing Protocols ---


class AudioSpeechRecognition(Protocol):
    """Protocol for automatic speech recognition component."""

    def transcribe(self, audio_data: bytes) -> str:
        """Convert audio data to text.

        Args:
            audio_data: Raw audio bytes to transcribe

        Returns:
            Transcribed text
        """
        ...


class InputProcessor(Protocol):
    """Protocol for processing user input."""

    def process_input(self, raw_input: Any) -> UserMessageProtocol:
        """Process raw user input into a normalized message.

        Args:
            raw_input: Raw input data (could be text or audio)

        Returns:
            Processed user message
        """
        ...

    def detect_input_type(self, raw_input: Any) -> InputType:
        """Detect the type of input.

        Args:
            raw_input: The raw input data

        Returns:
            The detected input type
        """
        ...


# --- RAG Component Protocols ---


class EmbeddingGenerator(Protocol):
    """Protocol for generating embeddings from text."""

    def embed(self, text: str) -> list[float]:
        """Generate embedding vector for text.

        Args:
            text: Input text

        Returns:
            Embedding vector
        """
        ...

    def embed_batch(self, texts: list[str]) -> list[list[float]]:
        """Generate embedding vectors for multiple texts.

        Args:
            texts: List of input texts

        Returns:
            List of embedding vectors
        """
        ...


class SimilarityCalculator(Protocol):
    """Protocol for calculating similarity between embeddings."""

    def calculate(
        self, query_embedding: list[float], document_embeddings: list[list[float]]
    ) -> list[float]:
        """Calculate similarity scores between query and documents.

        Args:
            query_embedding: Query embedding vector
            document_embeddings: List of document embedding vectors

        Returns:
            List of similarity scores
        """
        ...


class Database(Protocol):
    """Protocol for database operations."""

    def store_document(self, content: str, metadata: dict[str, Any]) -> str:
        """Store a document in the database.

        Args:
            content: Document content
            metadata: Document metadata

        Returns:
            Document ID
        """
        ...

    def retrieve_documents(
        self, query_embedding: list[float], limit: int = 5
    ) -> list[RetrievedDocument]:
        """Retrieve relevant documents based on query embedding.

        Args:
            query_embedding: Query embedding vector
            limit: Maximum number of documents to retrieve

        Returns:
            List of retrieved documents with relevance scores
        """
        ...

    def retrieve_by_metadata(
        self, metadata_filters: dict[str, Any], limit: int = 5
    ) -> list[RetrievedDocument]:
        """Retrieve documents based on metadata filters.

        Args:
            metadata_filters: Metadata filter criteria
            limit: Maximum number of documents to retrieve

        Returns:
            List of retrieved documents
        """
        ...


class RAGComponent(Protocol):
    """Protocol for the RAG (Retrieval-Augmented Generation) component."""

    def retrieve_context(
        self, query: str, conversation: ConversationProtocol, limit: int = 5
    ) -> list[RetrievedDocument]:
        """Retrieve relevant context based on query and conversation.

        Args:
            query: User query
            conversation: Conversation history
            limit: Maximum number of documents to retrieve

        Returns:
            List of retrieved documents
        """
        ...


# --- Contextual Information Protocols ---


class ContextProvider(Protocol):
    """Protocol for providing contextual information."""

    def get_current_datetime(self) -> datetime:
        """Get current date and time.

        Returns:
            Current date and time
        """
        ...

    def get_contextual_data(self) -> dict[str, Any]:
        """Get all available contextual data.

        Returns:
            Dictionary of contextual data
        """
        ...


# --- Prompt Assembly Protocols ---


class PromptAssembler(Protocol):
    """Protocol for assembling prompts for the LLM."""

    def assemble_prompt(
        self,
        user_message: UserMessageProtocol,
        conversation: ConversationProtocol,
        retrieved_contexts: list[RetrievedDocument],
        system_prompt: str,
        contextual_info: dict[str, Any],
    ) -> str:
        """Assemble a prompt for the LLM.

        Args:
            user_message: Current user message
            conversation: Conversation history
            retrieved_contexts: Retrieved context documents
            system_prompt: System prompt
            contextual_info: Contextual information

        Returns:
            Assembled prompt
        """
        ...

    def get_system_prompt(self) -> str:
        """Get the system prompt for the KIT Campus Navigator.

        Returns:
            System prompt
        """
        ...


# --- LLM Client Protocols ---


class LLMRequest(TypedDict):
    """Represents a request to an LLM."""

    prompt: str
    model: str
    temperature: float
    max_tokens: int
    stop_sequences: list[str] | None


class LLMResponse(TypedDict):
    """Represents a response from an LLM."""

    text: str
    usage: dict[str, int]  # tokens used
    model: str
    finish_reason: str


class LLMClient(Protocol):
    """Protocol for interacting with language models."""

    def generate(self, request: LLMRequest) -> LLMResponse:
        """Generate a response from the LLM.

        Args:
            request: LLM request parameters

        Returns:
            LLM response
        """
        ...

    def get_available_models(self) -> list[str]:
        """Get a list of available LLM models.

        Returns:
            List of model names
        """
        ...


# --- Response Parsing Protocols ---


class ActionType(Enum):
    NONE = auto()
    NAVIGATION_LINK = auto()  # Create a navigation link to a building
    OPEN_WEBSITE = auto()  # Open a website related to a building
    SHOW_OPENING_HOURS = auto()  # Show opening hours with current time context


class ActionProtocol(Protocol):
    """Protocol for a parsed action from the LLM response."""

    action_type: ActionType
    parameters: dict[str, Any]
    raw_text: str


class ResponseParser(Protocol):
    """Protocol for parsing responses from the LLM."""

    def parse(self, llm_response: LLMResponse) -> tuple[str, list[ActionProtocol]]:
        """Parse the LLM response to extract text and actions.

        Args:
            llm_response: Response from the LLM

        Returns:
            Tuple of (processed_text, extracted_actions)
        """
        ...

    def extract_actions(self, text: str) -> list[ActionProtocol]:
        """Extract actions from text.

        Args:
            text: Input text

        Returns:
            List of parsed actions
        """
        ...

    def format_hyperlinks(self, text: str) -> str:
        """Format hyperlinks in text.

        Args:
            text: Input text

        Returns:
            Text with formatted hyperlinks
        """
        ...


# --- Action Execution Protocols ---


class ActionExecutor(Protocol):
    """Protocol for executing actions."""

    def execute(self, action: ActionProtocol) -> dict[str, Any]:
        """Execute an action.

        Args:
            action: Action to execute

        Returns:
            Result of the action
        """
        ...

    def can_execute(self, action: ActionProtocol) -> bool:
        """Check if an action can be executed.

        Args:
            action: Action to check

        Returns:
            True if the action can be executed, False otherwise
        """
        ...


# --- Output Generation Protocols ---


class Translator(Protocol):
    """Protocol for translating text."""

    def translate(self, text: str, target_language: str) -> str:
        """Translate text to target language.

        Args:
            text: Input text
            target_language: Target language code

        Returns:
            Translated text
        """
        ...

    def detect_language(self, text: str) -> str:
        """Detect the language of text.

        Args:
            text: Input text

        Returns:
            Detected language code
        """
        ...


class TextToSpeech(Protocol):
    """Protocol for text-to-speech conversion."""

    def synthesize(self, text: str, voice_id: str = "default") -> bytes:
        """Convert text to speech.

        Args:
            text: Input text
            voice_id: Voice identifier

        Returns:
            Audio data
        """
        ...


class OutputGenerator(Protocol):
    """Protocol for generating system output."""

    def generate(
        self, text: str, actions: list[ActionProtocol], output_type: OutputType
    ) -> SystemMessageProtocol:
        """Generate system output.

        Args:
            text: Text content
            actions: List of actions
            output_type: Desired output type

        Returns:
            System message
        """
        ...
